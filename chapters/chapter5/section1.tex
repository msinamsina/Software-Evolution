\section{مقدمه و تعریف مهندسی معکوس}

مهندسی معکوس (\lr{Reverse Engineering}) در مهندسی نرم‌افزار به فرایندی گفته می‌شود که در آن یک نرم‌افزار موجود مورد تحلیل دقیق قرار می‌گیرد تا ساختار درونی، اجزا، وابستگی‌ها و منطق عملکرد آن شناخته شود، بدون این‌که لزوماً تغییری در سیستم ایجاد گردد \cite{pressman2020software}.

هدف اصلی مهندسی معکوس، بازیابی دانش از دست‌رفته یا مستندسازی‌نشده درباره‌ی سیستم است. به کمک مهندسی معکوس می‌توان فهمید که نرم‌افزار چگونه طراحی شده، اطلاعات چگونه در آن جریان دارد و بخش‌های مختلف آن چه ارتباطی با هم دارند.

برای مثال، اگر نرم‌افزاری در دسترس باشد ولی مستندات طراحی آن موجود نباشد، با مهندسی معکوس می‌توان از روی کدها و فایل‌های اجرایی، مستندات و مدل‌های طراحی را بازسازی کرد. این کار در پروژه‌هایی که نرم‌افزارهای قدیمی (\lr{Legacy Systems}) مورد استفاده قرار می‌گیرند، بسیار اهمیت دارد \cite{pressman2020software}.

\subsection{تمایز آن با Reengineering و Refactoring}

مفاهیم مهندسی معکوس، بازمهندسی (\lr{Reengineering}) و بازآرایی کد (\lr{Refactoring}) هرچند مشابه‌اند، ولی اهداف متفاوتی دارند.

\begin{itemize}
    \item \textbf{مهندسی معکوس (\lr{Reverse Engineering}):} هدف آن \textit{درک سیستم موجود} است؛ یعنی بررسی و تحلیل بدون تغییر کد منبع.
    \item \textbf{بازمهندسی (\lr{Reengineering}):} پس از شناخت کامل سیستم، آن را بازطراحی یا بازنویسی می‌کنیم تا عملکرد بهتر یا نگهداری آسان‌تری داشته باشد.
    \item \textbf{بازآرایی کد (\lr{Refactoring}):} تمرکز بر بهبود ساختار درونی کد منبع است، بدون اینکه رفتار کلی نرم‌افزار تغییر کند.
\end{itemize}

می‌توان گفت:
\begin{center}
مهندسی معکوس → شناخت سیستم \\
بازمهندسی → شناخت + تغییر ساختار کلی \\
بازآرایی → اصلاح درونی کد بدون تغییر عملکرد
\end{center}

در چرخه‌ی عمر نرم‌افزار، مهندسی معکوس نقش مهمی در مرحله‌ی نگهداری (\lr{Maintenance}) دارد، زیرا در این مرحله معمولاً نیاز به درک مجدد از ساختار و منطق سیستم احساس می‌شود.
