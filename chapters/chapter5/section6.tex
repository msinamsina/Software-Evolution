
\subsection*{مثال از تحلیل معکوس یک سیستم قدیمی یا نرم‌افزار متن‌باز}
یکی از مطالعات شاخص در این حوزه، پژوهش \en{Reverse engineering a legacy software in a complex system: A systems engineering approach} است که توسط \en{Maximiliano Moraga} و \en{Yang-Yang Zhao} در سال ۲۰۱۸ منتشر شده است؛ در این تحقیق یک نرم‌افزار میراثی که در قالب بخشی از سیستم پیچیده‌ای قرار داشت، مورد تحلیل معکوس قرار گرفت تا دلیل شکل‌گیری ساختار، منطق عملکرد، و جایگاه آن در بستر کلی سیستم بازشناسی شود \cite{moraga2018}.
در این مطالعه، تیم محققان با استفاده از مدل \en{CAFCR (Customer Objectives – Application – Function – Component – Resources)} و ابزارهای مهندسی معکوس، توانستند نقشه راه مرحله‌ای برای ارتقای تدریجی و همزمان نگه‌داری و توسعه نرم‌افزار میراثی تدوین کنند \cite{moraga2018}. 
به‌عنوان مثال، ابتدا نمودارهای رابطه‌ای بین مؤلفه‌ها، وابستگی‌های زمان‌بر و حرکت از معماری مونوپولی به معماری ماژولار استخراج شد، سپس بر اساس آن تصمیماتی برای بهبود کارایی، ارتقای قابلیت نگهداری و افزون‌کردن کارکردهای جدید اتخاذ گردید \cite{moraga2018}.
مطالعه دیگری تحت عنوان \en{Case Studies in Model-Driven Reverse Engineering} توسط \en{A. Pascal} و همکاران در سال ۲۰۱۹ ارائه شده است که در آن بازمهندسی سه نرم‌افزار عملیاتی با استفاده از رویکرد مدل‌محور بررسی شده است؛ در این نمونه، استخراج مدل‌های سطح بالا، تحلیل ماژول‌ها و طراحی مجدد با هدف کاهش فرسایش معماری انجام شده است \cite{pascal2019}.
این مثال‌ها نشان می‌دهند که تحلیل معکوس در نرم‌افزارهای میراثی صرفاً جهت استخراج کد نیست، بلکه درک منطق کسب‌وکار، وابستگی‌های پنهان، و ساختار معماری را نیز امکان‌پذیر می‌کند؛ ولی همزمان باید توجه داشت که هر پروژه پژوهشی یا صنعتی با محدودیت‌ها و پیچیدگی‌های خاص خود مواجه است.

\subsection*{بررسی خروجی‌های حاصل از فرآیند مهندسی معکوس}
در پروژه \en{Moraga و Zhao}، خروجی‌های مهمی حاصل شده است: از جمله بازسازی نمودار زمینه (\en{context diagram}) برای نرم‌افزار مورد بررسی، استخراج اهداف مشتریان، مشخص شدن معیارهای کیفیت در رابطه با بازار هدف و ترکیب آن با وابستگی فنی مؤلفه‌ها، که منجر به تدوین نقشه‌راه برای بازمهندسی تدریجی نرم‌افزار شد \cite{moraga2018}. 
این نقشه راه به شرکت امکان داد تا ضمن ادامه نگهداری سیستم قدیمی، به‌تدریج عملکردهای جدید را نیز افزوده و قابلیت نگهداری را ارتقا دهد.
در مطالعه \en{Pascal و همکاران}، یکی دیگر از خروجی‌های کلیدی، استخراج مدل‌های معماری (\en{architecture models}) و فرم‌های بصری وابستگی‌ها میان ماژول‌ها بود؛ این مدل‌ها کمک کردند تا مسیرهای پرتکرار تغییرات، نقاط بحرانی در سیستم و اجزایی که بیشترین پیچیدگی را داشتند شناسایی شوند \cite{pascal2019}. 
همچنین گزارش شده که این مدل‌سازی موجب کاهش هزینه نگهداری و کاهش فرسایش معماری شده است.
علاوه بر این، خروجی‌های عملی دیگری نیز شامل مستندسازی بازگشتی (\en{redocumentation}) سیستم، بازیابی دانش ضمنی کارکنان قدیمی، انتقال آن به اعضای تیم جدید، کاهش وابستگی به افراد خاص، و آماده‌سازی سیستم برای استقرار روش‌های نوین مانند \en{DevOps} بود. 
به‌عنوان مثال، مکانیسم‌های اتوماسیون استقرار (\en{CI/CD}) و کانتینری‌سازی پس از مهندسی معکوس بهتر قابل پیاده‌سازی شدند زیرا ساختار ماژولار بهتر درک شده بود.
با این حال، باید به این نکته نیز توجه شود که خروجی‌های مهندسی معکوس معمولاً به‌صورت کامل قابل تعمیم نیستند؛ یعنی مدل‌ها، نقشه‌ها و تصمیماتی که در یک سازمان حاصل شده، ممکن است در سازمان دیگر با زیرساختی متفاوت، قابل اجرا یا مؤثر نباشند. 
همچنین کیفیت خروجی‌ها وابسته به میزان دسترسی به کد، مستندسازی قبلی، همکاری تیم‌های پیشین، و ابزارهای تحلیل مورد استفاده است؛ در محیط‌هایی که مستندات کم است، خطای استخراج منطق می‌تواند زیاد شود.
