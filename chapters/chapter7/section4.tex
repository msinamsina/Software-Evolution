\section{نحوه کارکرد IDA-Pro و x64dbg}

ابزارهای IDA Pro و x64dbg، اگرچه هر دو در حوزه مهندسی معکوس و تحلیل بدافزار استفاده می‌شوند، اما دارای فلسفه‌های طراحی بنیادین متفاوتی هستند که آن‌ها را نه رقیب، بلکه مکمل یکدیگر می‌سازد. IDA Pro در وهله اول یک ابزار \textit{«تحلیل ایستا»} (Static-First) است که بر پایه یک پایگاه داده غنی از دیس‌اسمبلی کار می‌کند. در مقابل، x64dbg یک ابزار \textit{«تحلیل دینامیک»} (Dynamic-First) و متن‌باز است که منحصراً بر روی دیباگ کردن زنده‌ی فرآیندها در ویندوز تمرکز دارد.[\cite {stackexchange6911}] درک نحوه کارکرد هر یک از این ابزارها، کلید استفاده مؤثر از آن‌ها در جریان‌های کاری پیچیده است.

\subsection{موتور تحلیل استاتیک IDA Pro: از دیس‌اسمبلی تا گراف}

هسته اصلی قدرت IDA Pro در توانایی آن برای جداسازی کد (disassembly) نهفته است. IDA از یک الگوریتم پیشرفته به نام \textit{«تجزیه نزولی بازگشتی»} (Recursive Descent Disassembly) استفاده می‌کند. برخلاف ابزارهای ساده‌تری مانند \texttt{objdump} که از \textit{«جاروب خطی»} (Linear Sweep) استفاده می‌کنند و بایت به بایت کد را می‌خوانند (و به راحتی داده را با کد اشتباه می‌گیرند)، الگوریتم بازگشتی، جریان کنترل برنامه را دنبال می‌کند. این الگوریتم با شروع از نقطه ورود، هر دستور را تجزیه می‌کند و در صورت برخورد با دستورات پرش (jump) یا فراخوانی (call)، به صورت بازگشتی به آدرس‌های مقصد می‌رود تا آن‌ها را نیز تجزیه کند.\cite {devopsschool2025}

چالش اصلی این رویکرد، دستورات پرش غیرمستقیم (indirect calls/jumps) است، مانند \texttt{call eax} یا \texttt{jmp ecx}. از آنجایی که مقصد پرش در زمان تحلیل ایستا مشخص نیست، الگوریتم بازگشتی در این نقاط متوقف می‌شود. این ضعف می‌تواند باعث شود IDA بخش‌های بزرگی از کد را (به خصوص در بدافزارهای مبهم‌سازی شده) شناسایی نکند. IDA برای مقابله با این مشکل، از مجموعه‌ای از اکتشافات (heuristics) پیچیده برای شناسایی الگوهای رایج کامپایلر، به‌ویژه جداول پرش (jump tables) که برای پیاده‌سازی دستورات \texttt{switch} استفاده می‌شوند، بهره می‌برد. این ابزار دارای ساختارهای داخلی پیچیده‌ای (مانند \texttt{switch\_info\_ex\_t}) برای مدل‌سازی این جداول است  و به تحلیلگر اجازه می‌دهد تا به صورت دستی، مقاصد پرش‌های ناشناس را تعریف کند.cite {rahulsingh_staticdynamic}

خروجی نهایی این تحلیل، \textit{«گراف جریان کنترل»} (Control Flow Graph یا CFG) معروف IDA است. این گراف به صورت بصری بر پایه \textit{«ارجاعات متقابل»} (Cross-References یا Xrefs) ساخته می‌شود. در این گراف، فلش‌های رنگی، منطق برنامه را نشان می‌دهند: فلش‌های سبز و قرمز نشان‌دهنده شاخه‌های یک پرش شرطی (مثلاً \texttt{true} و \texttt{false}) و فلش‌های آبی نشان‌دهنده پرش‌های بدون شرط یا فراخوانی‌های توابع هستند. cite{pang2021}

\subsection{دیکامپایلر Hex-Rays: تبدیل اسمبلی به شبه‌کد}

ارزشمندترین بخش IDA Pro (که به صورت افزونه فروخته می‌شود)، دیکامپایلر Hex-Rays است. این دیکامپایلر فرآیند تبدیل کد اسمبلی به شبه‌کد C را در یک فرآیند چند مرحله‌ای انجام می‌دهد. ابتدا، کد اسمبلی سطح پایین به یک زبان میانی (Intermediate Language یا IL) به نام \textit{«میکروکد»} (Microcode) تبدیل می‌شود. این میکروکد، مستقل از پلتفرم است و بهینه‌سازی‌های اولیه روی آن صورت می‌گیرد. در مرحله بعد، این میکروکد به یک \textit{«درخت نحو مجرد»} (Abstract Syntax Tree یا AST) که در IDA با نام \texttt{CTree} شناخته می‌شود، تبدیل می‌گردد. در نهایت، این AST به شبه‌کد C بسیار خوانا تبدیل می‌شود که تحلیلگر می‌تواند آن را بررسی کند.\cite {trailofbits2022}

\subsection{تحلیل دینامیک IDA Pro: یکپارچه‌سازی دیباگر}

IDA Pro تنها یک دیس‌اسمبلر نیست، بلکه یک دیباگر قدرتمند نیز در خود دارد. وجه تمایز کلیدی دیباگر IDA، \textit{«یکپارچگی عمیق»} آن با پایگاه داده تحلیل ایستا (IDB) است. تحلیلگر، فرآیند دیباگ را مستقیماً از درون IDB که قبلاً تحلیل شده است، آغاز می‌کند. این بدان معناست که تمام نام‌های تغییر یافته، ساختارهای (structs) تعریف شده و کامنت‌های ثبت‌شده در طول تحلیل ایستا، در طول جلسه دیباگ زنده نیز در دسترس هستند. این یکپارچگی دوسویه است؛ اطلاعات کشف‌شده در طول تحلیل دینامیک (مانند مقادیر رجیسترها یا حافظه) می‌تواند برای حاشیه‌نویسی و غنی‌سازی پایگاه داده ایستا استفاده شود. \cite {stackexchange2347}

یکی از قدرتمندترین ویژگی‌های این یکپارچگی، قابلیت \texttt{Appcall} است. Appcall به تحلیلگر اجازه می‌دهد تا از طریق اسکریپت (IDAPython یا IDC)، توابع موجود در برنامه تحت دیباگ را مستقیماً فراخوانی کند. برای مثال، می‌توان یک روتین رمزگشایی در بدافزار را شناسایی کرد و سپس با استفاده از Appcall، داده‌های دلخواه را به آن ارسال و خروجی رمزگشایی‌شده را دریافت کرد، بدون آنکه نیاز به اجرای کامل برنامه باشد. معماری دیباگر IDA همچنین از حالت راه‌دور (Remote Debugging) پشتیبانی می‌کند (مثلاً از طریق \texttt{win32\_remote.exe}) که برای تحلیل بدافزار حیاتی است، زیرا به تحلیلگر اجازه می‌دهد IDA را در سیستم خود اجرا کند در حالی که بدافزار در یک محیط ایزوله (مانند ماشین مجازی) در حال اجرا و دیباگ است.\cite {lehigh2012}

\subsection{موتور تحلیل دینامیک x64dbg: معماری و اجرا}

x64dbg یک دیباگر سطح کاربر (user-mode) مدرن، متن‌باز و مختص ویندوز است. هسته اصلی دیباگ این ابزار بر پایه \texttt{TitanEngine} ساخته شده است. درک نحوه کار x64dbg مستلزم درک معماری چند نخی (multi-threaded) آن است. x64dbg از حداقل سه نخ اصلی استفاده می‌کند:\cite{elastic_hexrays}

۱. \textbf{نخ اصلی (Main Thread):} مسئول رابط کاربری گرافیکی (GUI) است که با Qt نوشته شده است.

۲. \textbf{نخ دستور (Command Thread):} دستورات وارد شده توسط کاربر را پردازش می‌کند.

۳. \textbf{نخ دیباگ (Debug Thread):} این نخ، \textit{«حلقه دیباگ»} (Debug Loop) واقعی را اجرا می‌کند.

دلیل این جداسازی بسیار مهم است. حلقه دیباگ بر اساس Windows Debug API کار می‌کند و باید به طور مداوم منتظر رویدادهای دیباگ از سوی سیستم‌عامل باشد (مثلاً با فراخوانی \texttt{WaitForDebugEvent}). این فراخوانی یک عملیات \textit{«مسدودکننده»} (blocking) است، یعنی تا زمانی که رویدادی (مانند برخورد با نقطه توقف) رخ ندهد، اجرای نخ متوقف می‌شود. اگر این حلقه در نخ اصلی GUI اجرا می‌شد، هر بار که برنامه تحت دیباگ متوقف بود، کل رابط کاربری x64dbg قفل می‌کرد. قرار دادن حلقه دیباگ در یک نخ جداگانه تضمین می‌کند که GUI همیشه پاسخگو باقی بماند. این ابزار از توابع استاندارد API ویندوز مانند \texttt{DebugActiveProcess} برای اتصال به فرآیندهای در حال اجرا استفاده می‌کند.\cite {hexrays_goomba}

\subsection{مکانیزم‌های نقطه توقف (Breakpoint) در x64dbg}

قدرت اصلی یک دیباگر در توانایی آن برای متوقف کردن اجرا در نقاط دلخواه نهفته است. x64dbg (و سایر دیباگرها) این کار را عمدتاً از طریق دو مکانیزم انجام می‌دهند:

۱. \textbf{نقاط توقف نرم‌افزاری (Software Breakpoints):} این حالت پیش‌فرض است. هنگامی که کاربر یک نقطه توقف (breakpoint) تنظیم می‌کند، دیباگر بایت اول دستورالعمل موجود در آن آدرس را در حافظه فرآیند هدف، با بایت \texttt{\$0xCC\$} جایگزین می‌کند.[43, 44, 45, 46] بایت \texttt{\$0xCC\$} کد دستوری (opcode) برای وقفه نرم‌افزاری \texttt{INT 3} است. هنگامی که پردازنده به این دستور می‌رسد، اجرای برنامه را متوقف کرده و یک استثنا (exception) ایجاد می‌کند. دیباگر این استثنا را دریافت می‌کند، کنترل را به دست می‌گیرد، بایت اصلی را در جای خود قرار می‌دهد (تا برنامه به حالت عادی بازگردد)، و منتظر دستور کاربر می‌ماند. مزیت این روش، تعداد نامحدود نقاط توقف است ؛ عیب آن این است که کد برنامه را تغییر می‌دهد (و در حافظه‌های فقط-خواندنی (ROM) کار نمی‌کند).\cite{hexrays_ida}

۲. \textbf{نقاط توقف سخت‌افزاری (Hardware Breakpoints):} این نقاط توقف از رجیسترهای ویژه‌ای در خود CPU به نام \textit{«رجیسترهای دیباگ»} (\texttt{\$DR0\$-\$DR7\$}) استفاده می‌کنند. رجیسترهای \texttt{\$DR0\$} تا \texttt{\$DR3\$} چهار آدرس حافظه را که باید در آن‌ها توقف صورت گیرد، ذخیره می‌کنند. رجیستر \texttt{\$DR7\$} (رجیستر کنترل) برای فعال‌سازی این نقاط توقف و تعیین \textit{«شرط»} توقف استفاده می‌شود. مزیت کلیدی HBP این است که می‌تواند اجرا را نه تنها در \textit{«اجرای دستور»} (execute) بلکه در \textit{«نوشتن در حافظه»} (write) یا \textit{«خواندن از حافظه / نوشتن در حافظه»} (read/write) نیز متوقف کند. این قابلیت برای ردیابی دسترسی به متغیرها حیاتی است. عیب اصلی آن‌ها محدودیت شدید تعداد است (معمولاً فقط ۴ عدد). x64dbg از این مکانیزم برای پیاده‌سازی \textit{«نقاط توقف حافظه»} (Memory Breakpoints) استفاده می‌کند.\cite{wikipedia_ida}

\subsection{مقایسه معماری و جریان کاری هم‌افزا (Synergistic Workflow)}

جدول زیر تفاوت‌های معماری کلیدی بین IDA Pro و x64dbg را خلاصه می‌کند:

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{ویژگی} & \textbf{IDA Pro} & \textbf{x64dbg} \\ \hline
\textbf{رویکرد اصلی} & تحلیل ایستا (Static-First) & تحلیل دینامیک (Dynamic-First) \\ \hline
\textbf{موتور هسته} & تجزیه نزولی بازگشتی و Hex-Rays  & \texttt{TitanEngine} (بر پایه Windows Debug API)  \\ \hline
\textbf{هدف تحلیل} & پایگاه داده IDB (مدل آفلاین برنامه) & حافظه زنده فرآیند (وضعیت آنی CPU) \\ \hline
\textbf{اسکریپت‌نویسی} & \texttt{IDAPython} (برای تحلیل IDB و \texttt{Appcall})  & SDK پلاگین (\texttt{C++/Python}) (برای واکنش به رویدادها) \\ \hline
\textbf{پلتفرم} & چندسکویی (Windows, macOS, Linux) & فقط ویندوز  \\ \hline
\textbf{مجوز} & تجاری (بسیار گران) & متن‌باز (رایگان) \\ \hline
\end{tabular}
\end{table}

این تفاوت‌ها منجر به یک جریان کاری هم‌افزا می‌شود که در تحلیل بدافزارهای مدرن ضروری است. یک تحلیلگر هرگز یکی را به جای دیگری استفاده نمی‌کند، بلکه از هر دو با هم استفاده می‌کند \cite{hexrays_appcall}:

۱. \textbf{گام اول (ایستا - IDA):} تحلیلگر فایل بدافزار را در IDA Pro بارگذاری می‌کند تا \textit{«نقشه»} کلی برنامه را به دست آورد. تحلیل ایستا و دیکامپایلر، ساختار کلی، توابع و منطق برنامه را آشکار می‌سازد.

۲. \textbf{گام دوم (مواجهه با مانع):} تحلیلگر به کدهای مبهم‌سازی‌شده (obfuscated) یا بخش‌هایی می‌رسد که در حافظه رمزگشایی می‌شوند (packed). تحلیل ایستا در اینجا متوقف می‌شود زیرا کد واقعی قابل مشاهده نیست.\cite{medium_x64dbg}

۳. \textbf{گام سوم (دینامیک - x64dbg):} تحلیلگر همان فایل را در x64dbg اجرا می‌کند. با استفاده از نقشه‌ای که از IDA به دست آورده، یک نقطه توقف دقیقاً \textit{بعد} از روتین رمزگشایی یا unpacker قرار می‌دهد و برنامه را اجرا می‌کند.

۴. \textbf{گام چهارم (استخراج حافظه):} پس از برخورد به نقطه توقف، بدافزار اکنون کد اصلی خود را در حافظه رمزگشایی کرده است. تحلیلگر از x64dbg برای \textit{«تخلیه»} (dump) این بخش از حافظه در یک فایل جدید استفاده می‌کند.\cite{oreilly_malware}

۵. \textbf{گام پنجم (ایستا - IDA):} در نهایت، تحلیلگر فایل dump شده‌ی \textit{«تمیز»} را مجدداً در یک نمونه جدید IDA Pro بارگذاری می‌کند. اکنون IDA می‌تواند کد واقعی و رمزگشایی‌شده را به طور کامل دیس‌اسمبل و دیکامپایل کند.\cite{malwarechronicles_breakpoints}

این چرخه «ایستا -> دینامیک -> ایستا» سنگ بنای مهندسی معکوس مدرن است و نشان می‌دهد که چگونه معماری‌های متفاوت IDA Pro و x64dbg برای حل یک مشکل واحد با یکدیگر همکاری می‌کنند.\c
\bibliographystyle{plain} 
\bibliography{References} 

\end{document}
