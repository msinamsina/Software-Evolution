\section{مطالعه موردی: تحلیل دینامیک یک آسیب‌پذیری سرریز بافر}
\label{sec:case_study_bof}

برای درک عمیق‌تر قدرت ابزارهای اشکال‌زدایی (\lr{Debuggers}) که در بخش‌های پیشین معرفی شدند، در این بخش یک سناریوی واقعی از تحلیل یک آسیب‌پذیری سرریز بافر (\lr{Buffer Overflow}) را بررسی می‌کنیم. این مطالعه موردی نشان می‌دهد که چگونه می‌توان از ابزارهایی مانند \lr{x64dbg} یا \lr{GDB} برای کالبدشکافی یک کرش (\lr{Crash})، درک جریان اجرا و کشف علت ریشه‌ای آسیب‌پذیری استفاده کرد.

\subsection{سناریو و هدف}
فرض کنید یک سرویس‌دهنده شبکه (\lr{Network Server}) ساده داریم که بر روی پورت ۸۰۸۰ گوش می‌دهد. گزارش شده است که ارسال یک بسته داده خاص باعث از کار افتادن (\lr{Crash}) این سرویس می‌شود. هدف ما استفاده از دیباگر برای پاسخ به سوالات زیر است:
\begin{enumerate}
    \item چرا برنامه کرش می‌کند؟ (نوع خطا)
    \item دقیقاً در کدام نقطه از حافظه و کد خطا رخ می‌دهد؟
    \item آیا این خطا قابل بهره‌برداری (\lr{Exploitable}) است؟
\end{enumerate}

\subsection{فاز ۱: بازتولید خطا و اتصال دیباگر}
ابتدا دیباگر (مثلاً \lr{x64dbg} در ویندوز یا \lr{GDB} در لینوکس) را به پروسه در حال اجرا متصل می‌کنیم (\lr{Attach}). سپس بسته مخرب را به سمت سرویس ارسال می‌کنیم.

به محض دریافت بسته، دیباگر اجرای برنامه را متوقف می‌کند (\lr{Pause}) و وضعیت پردازنده را در لحظه وقوع خطا نمایش می‌دهد. در این سناریو، با خطای \lr{Access Violation} (در ویندوز) یا \lr{Segmentation Fault} (در لینوکس) مواجه می‌شویم.

\subsection{فاز ۲: تحلیل وضعیت پردازنده و حافظه}
در این مرحله، پنجره‌های مختلف دیباگر اطلاعات حیاتی را در اختیار ما قرار می‌دهند:

\begin{itemize}
    \item \textbf{رجیسترها (\lr{Registers}):} مشاهده می‌کنیم که رجیستر اشاره‌گر دستور (\lr{EIP} در ۳۲ بیتی یا \lr{RIP} در ۶۴ بیتی) با مقدار غیرمعمولی مانند \texttt{0x41414141} (معادل رشته "AAAA") پر شده است. این نشان‌دهنده آن است که ورودی کاربر مستقیماً روی آدرس بازگشت تابع اثر گذاشته و کنترل جریان برنامه را در دست گرفته است.
    
    \item \textbf{پشته (\lr{Stack}):} با بررسی پنجره \lr{Stack View}، می‌بینیم که فضای پشته با الگوی تکرار‌شونده‌ای از کاراکترهای 'A' پر شده است. این تأیید می‌کند که یک سرریز بافر رخ داده و داده‌های ورودی از مرز بافر عبور کرده و آدرس بازگشت (\lr{Return Address}) ذخیره‌شده در پشته را بازنویسی کرده‌اند.
\end{itemize}

\subsection{فاز ۳: کشف علت ریشه‌ای (\lr{Root Cause Analysis})}
اکنون که می‌دانیم کنترل برنامه از دست رفته است، باید بفهمیم کدام تابع مسئول این خطا است.
\begin{enumerate}
    \item \textbf{بررسی پشته فراخوانی (\lr{Call Stack}):} اگر پشته کاملاً تخریب نشده باشد، دیباگر می‌تواند زنجیره توابع فراخوانی‌کننده را نمایش دهد.
    \item \textbf{تحلیل کد اسمبلی:} با نگاه به دستورالعمل‌های قبل از کرش در پنجره \lr{Disassembly}، متوجه می‌شویم که برنامه در حال اجرای یک دستور \texttt{RET} (بازگشت از تابع) بوده است.
    \item \textbf{یافتن تابع آسیب‌پذیر:} با دنبال کردن جریان اجرا به عقب، به تابعی می‌رسیم که عملیات کپی رشته را انجام داده است. معمولاً استفاده از توابع ناامن مانند \texttt{strcpy} یا \texttt{gets} بدون بررسی طول ورودی، عامل اصلی این نوع آسیب‌پذیری‌هاست.
\end{enumerate}

\subsection{فاز ۴: اصلاح و تایید}
پس از شناسایی تابع آسیب‌پذیر، توسعه‌دهنده کد را اصلاح می‌کند (مثلاً جایگزینی \texttt{strcpy} با \texttt{strncpy}). سپس با استفاده مجدد از دیباگر و ارسال همان بسته مخرب، تأیید می‌کنیم که برنامه دیگر کرش نمی‌کند و داده‌های اضافی به درستی مدیریت می‌شوند.

\section{نتیجه‌گیری فصل}
در این فصل، نقش حیاتی دیباگرها در چرخه حیات نرم‌افزار بررسی شد. از مفاهیم پایه مانند نقاط توقف (\lr{Breakpoints}) و اجرای گام‌به‌گام، تا معرفی ابزارهای قدرتمندی مانند \lr{IDA Pro}، \lr{Ghidra}، \lr{x64dbg} و \lr{GDB}.

نکات کلیدی که باید به خاطر سپرد:
\begin{itemize}
    \item \textbf{انتخاب ابزار مناسب:} برای تحلیل استاتیک و دید کلی، ابزارهایی مانند IDA و Ghidra مناسب‌ترند، در حالی که برای تحلیل رفتار لحظه‌ای و پویا، x64dbg و GDB گزینه‌های برتر هستند.
    \item \textbf{همگرایی تحلیل‌ها:} موثرترین روش تحلیل، ترکیب تحلیل استاتیک (بررسی کد) و دینامیک (مشاهده اجرا) است.
    \item \textbf{قدرت در دستان شما:} تسلط بر این ابزارها نه تنها برای مهندسان معکوس و تحلیلگران بدافزار، بلکه برای توسعه‌دهندگان نرم‌افزار جهت کشف باگ‌های پیچیده و بهبود کیفیت کد ضروری است.
\end{itemize}

با پایان این فصل، شما باید دید جامعی نسبت به اکوسیستم ابزارهای اشکال‌زدایی و نحوه استفاده از آن‌ها برای حل مسائل پیچیده نرم‌افزاری پیدا کرده باشید.

