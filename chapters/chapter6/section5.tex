\subsection{تعریف آدرس (Address)}
\textbf{آدرس} به مکان منحصر به فردی در حافظه اصلی (RAM) اشاره دارد که یک واحد داده (معمولاً یک بایت) در آن ذخیره شده است. پردازنده (CPU) برای دسترسی به داده‌ها یا دستورالعمل‌ها، از این آدرس‌ها استفاده می‌کند.
\begin{itemize}
\item در معماری‌های قدیمی‌تر مانند \lr{Intel 8086}، آدرس‌ها به صورت \textbf{آدرس فیزیکی} (\lr{Physical Address}) و در معماری‌های مدرن‌تر، اغلب به صورت \textbf{آدرس مجازی} (\lr{Virtual Address}) به برنامه ارائه می‌شوند که توسط واحد مدیریت حافظه (\lr{MMU}) به آدرس فیزیکی ترجمه می‌شوند.
\item آدرس‌دهی مستقیم و مطلق، مستقیماً به یک مکان خاص در حافظه اشاره می‌کند.
\end{itemize}


\subsection{تعریف آفست (Offset)}
\textbf{آفست} (جابجایی یا فاصله) بیانگر \textbf{فاصله} یک بایت داده یا یک دستورالعمل، از یک نقطه شروع مشخص (معمولاً ابتدای یک ساختار، آرایه، رکورد، یا سگمنت در معماری‌های سگمنتی) است.
\begin{itemize}
\item در معماری‌های سگمنتی (مانند \lr{Real Mode پردازنده ۸۰۸۶})، آدرس کامل یک مکان حافظه (\textbf{آدرس فیزیکی}) از ترکیب یک آدرس پایه (\lr{Base Address}) که در ثبات سگمنت ذخیره شده، و آفست به دست می‌آید.
\item آدرس فیزیکی $P$ از طریق فرمول زیر محاسبه می‌شود (در معماری ۸۰۸۶):
$$P = (\text{\lr{Segment Base}} \times 16) + \text{Offset}$$
\item آفست، در واقع، یک آدرس \textbf{نسبی} (\lr{Relative Address}) است.
\end{itemize}

\subsection{کاربرد در تحلیل باینری و مهندسی معکوس}
در تحلیل باینری (\lr{Binary Analysis}) و مهندسی معکوس (\lr{Reverse Engineering})، درک آدرس و آفست از اهمیت حیاتی برخوردار است.
\subsubsection{آدرس‌ها}
\begin{itemize}
\item \textbf{نقشه‌برداری حافظه:} آدرس‌های مجازی و فیزیکی برای تعیین محل قرارگیری توابع، داده‌ها و متغیرها در هنگام اجرای برنامه ضروری هستند.
\item \textbf{\lr{EIP/RIP (Instruction Pointer)}:} ثبات اشاره‌گر دستورالعمل (\lr{EIP در ۳۲ بیت و RIP در ۶۴ بیت}) همواره آدرس دستوری را که CPU قرار است اجرا کند، نگهداری می‌کند. تحلیلگر با بررسی تغییرات این ثبات می‌تواند مسیر اجرای برنامه (\lr{Control Flow}) را دنبال کند.
\item \textbf{\lr{Breakpoints:}} برای توقف اجرای برنامه در یک نقطه خاص (مثلاً ابتدای یک تابع مشکوک)، نیاز است که آدرس دقیق آن مکان در حافظه مشخص شود.
\end{itemize}

\subsubsection{آفست‌ها}
\begin{itemize}
\item \textbf{آدرس مجازی نسبی (RVA):} در ساختار فایل‌های اجرایی مانند \lr{PE (Windows)} و \lr{ELF (Linux)}، بسیاری از آدرس‌ها به صورت \lr{RVA (Relative Virtual Address)} ذخیره می‌شوند که در واقع آفست نسبت به آدرس مبدأ بارگذاری فایل در حافظه (\lr{Image Base}) هستند. این امر جابه‌جایی فایل اجرایی را در حافظه (ASLR) آسان می‌کند.
\item \textbf{تجزیه ساختارها:} آفست‌ها برای دسترسی به فیلدهای یک ساختار داده (مانند ساختارهای ویندوز، یا شیءها در برنامه‌نویسی شیءگرا) ضروری هستند. برای مثال، برای دسترسی به فیلد دوم یک ساختار، باید آفست آن فیلد نسبت به ابتدای ساختار مشخص شود.
\item \textbf{\lr{Buffer Overflow:}} در تحلیل آسیب‌پذیری‌های سرریز بافر (\lr{Buffer Overflow})، تعیین آفست دقیق برای رونویسی آدرس بازگشت (\lr{Return Address}) یا سایر داده‌های حساس (مانند اشاره‌گرهای پشته) یک مرحله کلیدی است.
\end{itemize}

\subsection{مثال‌های عددی}
\label{sec:examples}
\subsubsection{مثال ۱: آدرس‌دهی سگمنتی (8086)}
فرض کنید ثبات سگمنت داده ($DS$) حاوی مقدار $1000h$ و ثبات اندیس مبدأ ($SI$) (که به عنوان آفست عمل می‌کند) حاوی مقدار $00A0h$ باشد.
\begin{itemize}
\item \textbf{\lr{Segment Base (شیفت‌یافته)}:} $1000h \times 10h = 10000h$
\item \textbf{Offset:} $00A0h$
\item \textbf{آدرس فیزیکی:}
$$P = 10000h + 00A0h = 100A0h$$
\end{itemize}
دستور اسمبلی مانند \texttt{MOV AL, [SI]} داده‌ای که در آدرس فیزیکی $100A0h$ قرار دارد را به ثبات $AL$ منتقل می‌کند.
\subsubsection{مثال ۲: محاسبه آفست در آرایه}
در زبان اسمبلی (یا در زبان‌های سطح بالا مانند C) فرض کنید یک آرایه از اعداد صحیح ۴ بایتی (\texttt{int}) به نام \texttt{my_array} در آدرس پایه $B=0x400000$ تعریف شده باشد. برای دسترسی به عنصر شماره $i$ (که اندیس آن از صفر شروع می‌شود)، از آفست استفاده می‌شود.
\begin{itemize}
\item \textbf{فرمول آفست:} $\text{Offset} = i \times \text{\lr{Size of Element}}$
\item \textbf{آدرس عنصر سوم ($i=2$):}
$$\text{Address}(2) = B + (2 \times 4) = 0x400000 + 8 = 0x400008$$
\item در اینجا، مقدار $8$ (بایت) آفست عنصر سوم نسبت به ابتدای آرایه است.
\end{itemize}

\subsection{نکات کاربردی در مهندسی معکوس}
\label{sec:re_tips}
\begin{enumerate}
\item \textbf{محاسبه (RVA):} در مهندسی معکوس، اغلب نیاز است که آدرس‌های مجازی (VA) را به آفست‌های فایل (\lr{File Offsets}) تبدیل کنید تا بتوانید داده‌ها را در فایل باینری روی دیسک مشاهده یا تغییر دهید. این کار با استفاده از جدول سِکشن‌ها (\lr{Section Table}) در هدر فایل \lr{PE/ELF} انجام می‌شود.
\item \textbf{آدرس‌دهی نسبی به (RIP):} در معماری‌های ۶۴ بیتی (x64)، آدرس‌دهی نسبی به ثبات $RIP$ رایج است: \texttt{\lr{MOV EAX, [RIP + offset]}}. تحلیلگر باید مقدار آفست را به آدرس فعلی $RIP$ اضافه کند تا آدرس مقصد را پیدا کند. این امر به ویژه در کدهای مستقل از موقعیت (PIC) بسیار مهم است.
\item \textbf{آفست‌های پشته:} در هنگام بررسی توابع، متغیرهای محلی و پارامترهای تابع با استفاده از آفست‌هایی نسبت به ثبات پایه پشته ($EBP$/$RBP$) یا اشاره‌گر پشته ($ESP$/$RSP$) آدرس‌دهی می‌شوند. پیدا کردن آفست متغیرها نسبت به $RBP$ (مانند \texttt{\lr{[RBP - 0x20]}}) برای درک منطق تابع حیاتی است.
\end{enumerate}


