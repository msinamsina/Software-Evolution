\section{هربخش فایل PE چه اطلاعاتی دارد}

\subsection{هدر \lr{DOS}}
\label{subsec:ch6-2-1-dosheader}

بخش آغازین هر فایل اجرایی در ویندوز با ساختاری موسوم به \lr{DOS Header} مشخص می‌شود. این ساختار که با امضای دودویی \lr{MZ} (برگرفته از نام \lr{Mark Zbikowski}) آغاز می‌گردد، در اصل بازمانده‌ای از قالب‌های اجرایی \lr{MS-DOS} است و برای حفظ سازگاری عقب‌رو در فایل‌های اجرایی مدرن همچنان نگه داشته شده است. هدر \lr{DOS} معمولاً ۶۴ بایت نخست فایل را دربر می‌گیرد و شامل تعدادی فیلد از پیش تعریف‌شده است که اطلاعات پایه‌ای درباره‌ی تصویر اجرایی را ذخیره می‌کنند.

یکی از مهم‌ترین فیلدهای این ساختار، مقدار چهار‌بایتی \lr{e\_lfanew} است. این فیلد آفستِ محل شروع هدر اصلی فایل، یعنی \lr{PE (NT) Header} را نسبت به ابتدای فایل مشخص می‌کند. لودر ویندوز با اتکا به همین مقدار می‌تواند به نقطه‌ی دقیقی که ساختار \lr{PE} در آن قرار گرفته دسترسی پیدا کرده و فرایند بارگذاری تصویر را در حافظه آغاز کند. بدیهی است در صورتی‌که این مقدار نادرست باشد یا به ناحیه‌ای نامعتبر اشاره کند، سیستم‌عامل قادر نخواهد بود فایل را به‌عنوان یک تصویر اجرایی معتبر تشخیص دهد و بارگذاری آن متوقف می‌شود.

پس از فیلدهای هدر \lr{DOS}، بخشی کوتاه از کد اجرایی موسوم به \lr{DOS Stub} قرار می‌گیرد. هدف از این بخش، تضمین رفتار قابل‌قبول در محیط‌هایی است که از قالب \lr{PE} پشتیبانی نمی‌کنند. این کد معمولاً در صورت اجرای فایل در سیستم‌های قدیمی یا محیط‌های ناسازگار، تنها یک پیام ساده (مانند «این برنامه را باید در ویندوز اجرا کنید») نمایش داده و از ادامه‌ی اجرا جلوگیری می‌کند. در سیستم‌های امروزی این کد عملاً اجرا نمی‌شود، اما وجودش بخشی از قالب استاندارد فایل‌های اجرایی ویندوز است.

از منظر تحلیل معکوس و بررسی‌های امنیتی، مطالعه‌ی مقادیر موجود در \lr{DOS Header} می‌تواند نشانه‌هایی از دست‌کاری، پکر شدن فایل یا تلاش برای پنهان‌سازی ساختار واقعی تصویر را آشکار کند. هرچند این بخش در روند اجرای واقعی برنامه نقش کاربردی مستقیمی ندارد، اما برای آن‌که فایل توسط ویندوز به‌عنوان یک تصویر اجرایی معتبر در نظر گرفته شود باید وجود داشته باشد و مقادیر کلیدی آن (به‌ویژه \lr{e\_lfanew}) صحیح باشند. برای جزئیات بیشتر می‌توان به مستندات رسمی مایکروسافت درباره‌ی قالب \lr{PE} و همچنین منابع تحلیلی حوزه‌ی بدافزار مراجعه کرد \cite{MicrosoftPEFormatSpecification,TechZealotsPEStructureMalware}.

\subsection{هدر \lr{PE}}
\label{subsec:ch6-2-2-peheader}

پس از بخش ابتدایی \lr{DOS Header}، فایل اجرایی وارد مرحله‌ای می‌شود که ساختار واقعی قابل‌اجرای ویندوز را تشکیل می‌دهد. این بخش با امضای چهار بایتی \lr{PE\textbackslash0\textbackslash0} آغاز می‌شود و به عنوان نقطه‌ی شروع هدر اصلی یا همان \lr{NT Header} شناخته می‌شود. در این بخش، اطلاعات حیاتی درباره‌ی ماهیت فایل و نحوه‌ی بارگذاری آن در حافظه ذخیره شده است. سیستم‌عامل ویندوز در هنگام اجرای برنامه، ابتدا به این بخش مراجعه می‌کند تا بر اساس مقادیر موجود در آن، نقشه‌ی حافظه‌ی برنامه را ایجاد کرده و بخش‌های مختلف فایل را در موقعیت‌های مناسب بارگذاری کند.

ساختار کلی هدر \lr{PE} شامل سه بخش است: امضا، هدر فایل (\lr{COFF File Header}) و هدر اختیاری (\lr{Optional Header}). امضای \lr{PE\textbackslash0\textbackslash0} نشانه‌ای است که سیستم از طریق آن تشخیص می‌دهد فایل متعلق به قالب اجرایی مدرن ویندوز است. در ادامه، هدر فایل اطلاعات پایه‌ای نظیر نوع پردازنده‌ی هدف، تعداد بخش‌ها، زمان کامپایل و ویژگی‌های کلی فایل را در خود دارد. بخش اختیاری، علی‌رغم نام آن، جزئی حیاتی از این ساختار است و داده‌هایی مانند آدرس نقطه‌ی ورود برنامه، اندازه‌ی کلی تصویر در حافظه، نسخه‌ی زیرسیستم اجرایی، و مسیرهای جداول داده‌ای نظیر \lr{import}، \lr{export}، \lr{resources} و \lr{relocation} را تعریف می‌کند. این داده‌ها به لودر ویندوز امکان می‌دهند تا به‌صورت نظام‌مند و دقیق، برنامه را در فضای مجازی حافظه سازمان‌دهی کرده و ارتباط آن را با کتابخانه‌های اشتراکی برقرار کند.

اهمیت این ساختار فراتر از نقش فنی آن در اجرای برنامه‌هاست و می‌توان آن را نمونه‌ای از تکامل تدریجی معماری نرم‌افزار در سطح سیستم‌عامل دانست. قالب \lr{PE} در واقع حاصل فرگشت فرمت‌های اجرایی قدیمی‌تر مانند \lr{MZ} و \lr{NE} است که در دوران گذار از محیط خط فرمان \lr{DOS} به معماری چندوظیفه‌ای \lr{Windows NT} شکل گرفت. در این روند، مایکروسافت تلاش کرد قالبی ارائه دهد که در عین حفظ سازگاری با گذشته، بتواند پاسخ‌گوی نیازهای روزافزون در زمینه‌ی امنیت، چندمعماری بودن، و توسعه‌پذیری باشد. نتیجه، ساختاری بود که نه‌تنها اطلاعات لازم برای اجرای فایل را نگهداری می‌کند، بلکه بستری منعطف برای افزوده شدن قابلیت‌های جدید در گذر زمان فراهم می‌آورد.

از منظر تکامل نرم‌افزاری، پایداری و تداوم این ساختار در نسخه‌های مختلف ویندوز بیانگر نوعی تعهد به اصل «پایداری رابط‌ها» است. این اصل تضمین می‌کند که ابزارها، کتابخانه‌ها و حتی نرم‌افزارهایی که دهه‌ها پیش توسعه یافته‌اند، همچنان بتوانند با نسخه‌های جدید سیستم‌عامل تعامل داشته باشند. همین پایداری است که باعث شده قالب \lr{PE} طی بیش از سه دهه، بدون نیاز به بازنویسی بنیادی، بتواند تغییرات مهمی مانند پشتیبانی از معماری ۶۴ بیتی، امضای دیجیتال، حفاظت از فضاهای حافظه و بارگذاری تصادفی (\lr{ASLR}) را در خود جای دهد. به بیان دیگر، \lr{PE Header} نه‌تنها بخشی از ساختار فایل اجرایی است، بلکه نمود عینی مفهوم «تکامل پایدار» در مهندسی نرم‌افزار محسوب می‌شود؛ مفهومی که در آن، طراحی اولیه به اندازه‌ای منعطف و تعمیم‌پذیر است که امکان رشد و گسترش در گذر زمان را بدون از دست دادن سازگاری فراهم می‌کند.

در زمینه‌ی تحلیل بدافزار نیز، \lr{PE Header} به عنوان نقطه‌ای کلیدی برای شناسایی ویژگی‌های رفتاری فایل شناخته می‌شود. بررسی دقیق فیلدهای این بخش می‌تواند سرنخ‌هایی درباره‌ی نوع کامپایلر، مسیرهای کتابخانه‌های واردشده، و حتی وجود تغییرات غیرعادی ناشی از بسته‌بندی یا رمزگذاری ارائه دهد. به همین دلیل، این بخش نه‌تنها در اجرای فایل، بلکه در تحلیل و درک رفتار آن نیز نقشی بنیادین دارد.

در مجموع، \lr{PE Header} را می‌توان هسته‌ی منطقی فرمت اجرایی ویندوز دانست؛ بخشی که با وجود ظاهر فنی و ثابت خود، بازتابی از رویکرد تکاملی در طراحی نرم‌افزار است، رویکردی که به‌جای جایگزینی کامل ساختارها، آن‌ها را به‌تدریج غنی‌تر و پایدارتر می‌سازد.\cite{MicrosoftPEFormatSpecification}.


\subsection{جدول بخش‌ها (\lr{Section Table})}
\label{subsec:ch6-2-3-section-table}

پس از پایان هدر \lr{PE}، ساختاری با عنوان \lr{Section Table} یا جدول بخش‌ها قرار دارد که نقش آن تعریف اجزای اصلی فایل اجرایی است. این جدول بلافاصله پس از هدر اختیاری قرار می‌گیرد و شامل آرایه‌ای از ساختارهای تکرارشونده موسوم به \lr{IMAGE\_SECTION\_HEADER} است؛ هر یک از این ساختارها نماینده‌ی یکی از بخش‌های فایل (مانند \lr{.text}، \lr{.data}، \lr{.rdata}، \lr{.rsrc} و غیره) محسوب می‌شوند. تعداد ورودی‌های جدول برابر با مقداری است که در فیلد \lr{NumberOfSections} از \lr{File Header} مشخص شده است و ترتیب آن‌ها دقیقاً با ترتیب فیزیکی بخش‌ها در فایل هم‌خوانی دارد.

هر ورودی جدول شامل اطلاعات دقیق مربوط به نام بخش، اندازه‌ی مجازی آن در حافظه، اندازه‌ی واقعی آن در فایل، آدرس مجازی شروع بخش (\lr{VirtualAddress})، مکان شروع داده‌ها در فایل (\lr{PointerToRawData}) و مجموعه‌ای از پرچم‌ها (\lr{Characteristics}) است که نوع دسترسی آن بخش را تعیین می‌کنند. برای نمونه، بخش \lr{.text} معمولاً با پرچم‌های قابل‌اجرا و فقط‌خواندنی مشخص می‌شود، در حالی‌که \lr{.data} قابل‌نوشتن است. لودر ویندوز در زمان بارگذاری برنامه، بر اساس همین مقادیر تصمیم می‌گیرد که هر بخش را در کجای حافظه مستقر کرده و چه سطحی از دسترسی به آن اختصاص دهد. به این ترتیب، \lr{Section Table} را می‌توان نقشه‌ی دقیق تخصیص حافظه و نحوه‌ی سازمان‌دهی کد و داده در محیط اجرایی دانست.

در سطح ساختاری، ترتیب و چیدمان بخش‌ها انعکاس‌دهنده‌ی منطق کامپایلر و پیونددهنده (\lr{linker}) است؛ برای مثال، بخش \lr{.text} معمولاً در ابتدای تصویر قرار می‌گیرد زیرا شامل دستورالعمل‌های اجرایی است و پس از آن داده‌ها، منابع و اطلاعات باز‌اسکان‌پذیری جای می‌گیرند. در بسیاری از فایل‌های سیستمی یا بدافزارها، تغییر در توالی یا اندازه‌ی این بخش‌ها می‌تواند نشانه‌ای از فشرده‌سازی، رمزگذاری یا تزریق کد باشد. از این رو، تحلیل‌گران امنیتی همواره جدول بخش‌ها را یکی از نخستین نقاط بررسی خود قرار می‌دهند تا بتوانند تفاوت میان ساختار واقعی و ساختار مورد انتظار را شناسایی کنند.

از منظر تکامل نرم‌افزاری، مفهوم \lr{Section Table} بیانگر یکی از اصول بنیادی طراحی ماژولار در معماری سیستم‌های اجرایی است. تقسیم فایل به بخش‌های مستقل با کارکردهای مشخص، امکان توسعه و نگهداری تدریجی را فراهم کرده است. به همین دلیل، قالب \lr{PE} در طول دهه‌ها بدون تغییر اساسی در منطق خود، توانسته از افزوده شدن ویژگی‌های متنوعی مانند داده‌های منابع چندزبانه، متادیتاهای مدیریت‌شده در \lr{.NET}، و بخش‌های مخصوص به امضاهای دیجیتال پشتیبانی کند. این پایداری ساختاری، نشان‌دهنده‌ی درک عمیق طراحان از نیاز به انعطاف‌پذیری بلندمدت در طراحی قالب‌های اجرایی است؛ مفهومی که ارتباط مستقیمی با اصول تکامل پایدار نرم‌افزار دارد.

در مجموع، \lr{Section Table} نقطه‌ی اتصال میان ساختار منطقی برنامه و بازنمایی فیزیکی آن در حافظه است. بدون این جدول، لودر ویندوز قادر نخواهد بود بخش‌های مختلف فایل را به‌درستی از روی دیسک به حافظه منتقل کند یا دسترسی‌های لازم را برای اجرای ایمن فراهم آورد. این بخش نه‌تنها عنصر حیاتی در بارگذاری برنامه است، بلکه در تحلیل ساختار فایل و تشخیص تغییرات غیرمجاز نیز جایگاهی اساسی دارد؛ به گونه‌ای که کوچک‌ترین انحراف در مقادیر آن می‌تواند چهره‌ی واقعی یک فایل سالم یا مخرب را آشکار سازد.\cite{MicrosoftPEFormatSpecification}.
\begin{table}[H]
    \centering
    \begin{tabular}{c c l p{7cm}}
        \toprule
        \textbf{Offset} & \textbf{Size} & \textbf{Field} & \textbf{Description} \\
        \midrule
        0  & 8 & \lr{Name} & نام بخش به‌صورت رشتهٔ ۸ بایتی (اگر طول کمتر باشد با صفر پُر می‌شود). \\
        8  & 4 & \lr{VirtualSize} & اندازهٔ بخش هنگام بارگذاری در حافظه؛ اگر از \lr{SizeOfRawData} بزرگ‌تر باشد، انتها صفر می‌شود. \\
        12 & 4 & \lr{VirtualAddress} & آدرس مجازی شروع بخش نسبت به مبنای تصویر هنگام بارگذاری. \\
        16 & 4 & \lr{SizeOfRawData} & اندازهٔ دادهٔ بخش روی دیسک؛ باید با مقدار \lr{FileAlignment} در هدر اختیاری هم‌تراز باشد. \\
        20 & 4 & \lr{PointerToRawData} & اشاره‌گر فایل به ابتدای داده‌های این بخش در تصویر \lr{PE}/\lr{COFF}. \\
        24 & 4 & \lr{PointerToRelocations} & محل ورودی‌های جابجایی برای این بخش؛ در تصاویر اجرایی معمولاً صفر است. \\
        28 & 4 & \lr{PointerToLinenumbers} & محل ورودی‌های شماره‌خط \lr{COFF}؛ برای تصاویر اجرایی صفر است. \\
        32 & 2 & \lr{NumberOfRelocations} & تعداد ورودی‌های جابجایی در این بخش؛ برای تصاویر اجرایی صفر است. \\
        34 & 2 & \lr{NumberOfLinenumbers} & تعداد ورودی‌های شماره‌خط در این بخش؛ برای تصاویر اجرایی صفر است. \\
        36 & 4 & \lr{Characteristics} & پرچم‌های توصیف‌کنندهٔ ویژگی‌های بخش (قابل‌اجرا، قابل‌نوشتن، فقط‌خواندنی و ...). \\
        \bottomrule
    \end{tabular}
    \caption{ساختار کلی هر ورودی در جدول بخش‌ها (\lr{Section Table Entry}) در قالب فایل \lr{PE} \cite{MicrosoftPEFormatSpecification}}
    \label{tab:section-table-entry}
\end{table}
\subsection{بخش‌های \lr{.text}، \lr{.data} و \lr{.rdata}}
\label{subsec:ch6-2-4-text-data-rdata}

در ادامهٔ ساختار فایل اجرایی، بخش‌های مختلفی وجود دارند که هرکدام نقش خاصی در سازمان‌دهی کد و داده در حافظه ایفا می‌کنند. این بخش‌ها در جدول بخش‌ها تعریف می‌شوند و از طریق فیلدهای مشخص‌شده در هر ورودی جدول، لودر سیستم‌عامل می‌داند چگونه باید آن‌ها را در فضای مجازی حافظه نگاشت کند. از میان این بخش‌ها، سه بخش \lr{.text}، \lr{.data} و \lr{.rdata} تقریباً در تمام فایل‌های اجرایی ویندوز وجود دارند و پایه‌ی عملکردی برنامه را تشکیل می‌دهند.

بخش \lr{.text} به عنوان اصلی‌ترین بخش اجرایی، شامل تمامی دستورالعمل‌های ماشین و منطق برنامه است. کدهای ترجمه‌شده از زبان سطح بالا در زمان کامپایل در این بخش قرار می‌گیرند. آدرس نقطه‌ی ورود (\lr{Entry Point}) برنامه نیز در بیشتر موارد در همین بخش قرار دارد. از آن‌جا که محتوای این بخش باید توسط پردازنده به عنوان دستورالعمل اجرا شود، سیستم‌عامل آن را با سطح دسترسی «قابل اجرا و فقط‌خواندنی» (\lr{Execute / Read}) در حافظه نگاشت می‌کند تا از تغییر تصادفی یا عمدی کد در زمان اجرا جلوگیری شود. در معماری امنیتی ویندوز، همین تفکیک اجازه داده است که سازوکارهایی نظیر \lr{DEP (Data Execution Prevention)} مؤثر واقع شوند؛ به این معنا که فقط نواحی متعلق به \lr{.text} و بخش‌های مشخص‌شده مجاز به اجرا هستند. در نتیجه، دستکاری در این بخش یا تزریق کد جدید در نواحی داده‌ای توسط بدافزارها می‌تواند از طریق مقایسهٔ اندازه‌ها و هش این بخش شناسایی گردد. علاوه بر این، الگوی چینش توابع در \lr{.text} معمولاً سرنخ‌های مهمی درباره‌ی کامپایلر، بهینه‌سازی‌ها و حتی زبان برنامه‌نویسی به‌کاررفته فراهم می‌کند که در تحلیل مهندسی معکوس کاربرد دارد.

در مقابل، بخش \lr{.data} برای نگهداری داده‌های اولیه‌شده‌ای استفاده می‌شود که برنامه در طول اجرای خود نیاز به خواندن یا تغییر آن‌ها دارد. به بیان دیگر، هر متغیر سراسری یا ایستا که در زمان کامپایل مقدار مشخصی دریافت کرده باشد، در این بخش ذخیره می‌شود. سیستم‌عامل هنگام بارگذاری برنامه، مقادیر این بخش را به همان شکل در حافظه کپی می‌کند و اجازه‌ی خواندن و نوشتن (\lr{Read / Write}) به آن می‌دهد. تفاوت این بخش با \lr{.bss} (که برای داده‌های مقداردهی‌نشده است) در همین مقدار اولیه نهفته است. تحلیل‌گران امنیتی معمولاً این بخش را برای یافتن داده‌های حساس، کلیدهای رمزنگاری یا مقادیر پیکربندی بررسی می‌کنند. از منظر طراحی نرم‌افزار، وجود \lr{.data} نمادی از جداسازی داده و منطق در سطح ماشین است؛ تفکیکی که امکان بهینه‌سازی مصرف حافظه و اجرای امن‌تر را فراهم می‌کند.

در کنار این دو، بخش \lr{.rdata} یا \lr{Read-Only Data} جایگاهی میان کد و داده دارد. همان‌گونه که از نامش پیداست، داده‌های موجود در این بخش پس از بارگذاری در حافظه غیرقابل تغییر هستند. این داده‌ها معمولاً شامل رشته‌های ثابت، جداول ثابت برنامه، اشاره‌گرهای تابع، مقادیر ثابت کامپایل‌شده و همچنین جداول واردات (\lr{Import Tables}) و صادرات (\lr{Export Tables}) هستند. لودر ویندوز از اطلاعات این بخش برای پیوند دادن تابع‌های خارجی و کتابخانه‌های اشتراکی استفاده می‌کند. برای مثال، جدول واردات در \lr{.rdata} مشخص می‌کند که برنامه از چه توابعی در چه کتابخانه‌هایی مانند \lr{kernel32.dll} یا \lr{user32.dll} استفاده می‌کند. در نتیجه، \lr{.rdata} نه‌تنها محل داده‌های غیرقابل تغییر است، بلکه در عمل نقشه‌ی وابستگی‌های خارجی برنامه را نیز در خود دارد. به دلیل همین نقش دوگانه، دستکاری در این بخش یکی از روش‌های رایج در بدافزارها برای پنهان‌سازی رفتار واقعی یا تغییر مسیر فراخوانی توابع سیستمی است.

از دیدگاه تکامل نرم‌افزاری، تقسیم ساختار فایل اجرایی به بخش‌هایی با ماهیت متفاوت، مصداقی روشن از طراحی ماژولار و اصل \lr{Separation of Concerns} (تفکیک نگرانی‌ها) است. در نسخه‌های اولیهٔ سیستم‌عامل \lr{DOS}، تمام کد و داده در یک فضای خطی قرار می‌گرفت و مدیریت آن‌ها به شکل دستی صورت می‌گرفت. اما در معماری \lr{NT} و فرمت \lr{PE}، هر بخش دارای هدف، سطح دسترسی و محدودیت‌های تعریف‌شده است. این طراحی باعث شد قالب \lr{PE} بتواند بدون تغییر بنیادی، با پیشرفت معماری‌های پردازنده و افزوده شدن ویژگی‌های امنیتی جدید، همچنان پایدار بماند. برای مثال، افزودن بخش‌های خاص مانند \lr{.tls} (\lr{Thread Local Storage}) یا \lr{.pdata} در نسخه‌های جدیدتر، بدون تأثیر منفی بر ساختار موجود ممکن شد، زیرا هستهٔ طراحی بر پایه‌ی بخش‌بندی استاندارد استوار بود.

بدین ترتیب، بخش‌های \lr{.text}، \lr{.data} و \lr{.rdata} در کنار یکدیگر نمایانگر سه بُعد اصلی یک برنامهٔ اجرایی هستند: منطق، وضعیت و ثبات. منطق در \lr{.text} تجلی می‌یابد، وضعیت در \lr{.data} حفظ می‌شود، و ثبات در \lr{.rdata} تبلور می‌یابد. این سه‌گانه نه‌تنها اساس اجرای برنامه را شکل می‌دهند، بلکه بازتابی از روند تکامل مفهومی نرم‌افزار از ساختارهای یکنواخت به معماری‌های تفکیک‌شده و قابل نگهداری هستند.\cite{MicrosoftPEFormatSpecification}.
