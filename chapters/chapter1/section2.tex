\subsection{مدل کد و فیکس (\lr{Code-and-Fix})}
در دهه‌های 1950 و 1960، توسعه نرم‌افزار عمدتاً به‌صورت "کد و فیکس" انجام می‌شد. در این روش، تیم توسعه مستقیماً شروع به نوشتن کد می‌کرد و در صورت بروز خطا یا مشکل، آن را در حین کار اصلاح می‌نمود. هیچ مستندسازی، برنامه‌ریزی دقیق یا تحلیل اولیه وجود نداشت.\cite{Software-development-history}

\noindent \textbf{مزایا:} سرعت شروع بالا و مناسب برای پروژه‌های کوچک و کوتاه‌مدت.\cite{Software-development-history}

\noindent \textbf{معایب:} نگهداری دشوار، افزایش هزینه در مراحل پایانی، نبود امکان پیش‌بینی خطاها و زمان تحویل.\cite{Software-development-history}



\subsection{مدل آبشاری (\lr{Waterfall})}
مدل آبشاری در دهه‌ی 1970 معرفی شد و نخستین مدل ساختارمند مهندسی نرم‌افزار به‌شمار می‌رود. این مدل شامل مراحلی پی‌در‌پی است که هر مرحله پس از اتمام مرحله‌ی قبل آغاز می‌شود. مراحل اصلی آن عبارت‌اند از: تحلیل نیازمندی‌ها، طراحی سیستم، پیاده‌سازی، آزمون، استقرار و نگهداری. در این روش، هر مرحله باید به‌طور کامل قبل از شروع مرحله بعدی به پایان برسد.\cite{Software-development-history}

\noindent \textbf{مزایا:} ساختار مشخص و ساده، مستندسازی کامل و مناسب برای پروژه‌های با نیازهای پایدار.\cite{Software-development-history}

\noindent \textbf{معایب:} انعطاف‌پذیری پایین در مواجهه با تغییرات، عدم امکان بازگشت به مراحل قبلی، تاخیر در کشف خطاها تا مراحل پایانی و سختی در تعامل مداوم با مشتری. اغلب برای مشتری مشکل است که تمامی نیازهای خود را به طور کامل و مشخص بیان کند، مدل آبشاری به این امر نیاز داشته و در مواجه با عدم قطعیت طبیعی که در آغاز بسیاری از پروژه‌ها وجود دارد، مشکل دارد.\cite{Software-development-history}

با وجود محدودیت‌ها، مدل آبشاری هنوز در پروژه‌های دولتی و نظامی با الزامات دقیق مورد استفاده قرار می‌گیرد.\cite{Software-development-history}

\subsection{مدل افزایشی و تکاملی (\lr{Incremental \& Evolutionary})}
در دهه 1980، با رشد نیاز به سیستم‌های پویا و قابل انطباق، مدل‌های افزایشی و تکاملی ظهور کردند. مدل افزایشی، مدل آبشاری را به طور تکرار شونده به کار میگیرد. در این مدل، نرم‌افزار در چند نسخه یا "افزونه" تولید می‌شود و هر نسخه بخشی از قابلیت‌های سیستم نهایی را ارائه می‌دهد. مدل تکاملی نیز بر پایه بازخورد مداوم از کاربران و بهبود تدریجی نسخه‌ها بنا شده است.\cite{Software-development-history}

\noindent \textbf{مزایا:} تحویل سریع نسخه‌های اولیه، امکان دریافت بازخورد از کاربر، امکان اعمال تغییرات در طول توسعه و کاهش ریسک پروژه.\cite{Software-development-history}

\noindent \textbf{معایب:} نیاز به برنامه‌ریزی دقیق و هماهنگی بین نسخه‌ها، و گاهی پیچیدگی در مدیریت تغییرات.\cite{Software-development-history}

این رویکرد زمینه‌ساز مدل‌های مدرن‌تر مانند مدل مارپیچی و روش‌های چابک شد.

\subsection{مدل مارپیچی (\lr{Spiral Model})}
مدل مارپیچی که توسط بَری بوم در سال 1986 معرفی شد، ترکیبی از مدل آبشاری و تکاملی است و بر تحلیل ریسک در هر تکرار تمرکز دارد. این مدل شامل چهار فاز تکرارشونده است: برنامه‌ریزی، تحلیل ریسک، مهندسی و ارزیابی. پروژه در چندین چرخه (مارپیچ) تکرار می‌شود تا محصول نهایی به بلوغ برسد.\cite{Software-development-history}

با شروع فرآیند، تیم مهندسی نرم‌افزار در جهت عقربه‌های ساعت، حرکت در مارپیچ را آغاز می‌کند و این کار از مرکز شروع می‌شود. اولین مدار حول مارپیچ ممکن است منجر به تولید مشخصه محصول شود. با عبور از هر مرحله منطقه برنامه‌ریزی، کارهای تطابقی با طرح پروژه صورت می‌گیرد. هزینه و زمانبندی بر اساس بازخورد ارزیابی مشتری، تنظیم می گردند. علاوه بر آن مدیر پروژه تعداد تکرارهای تنظیم شده لازم برای تکمیل نرم افزار را تعیین میکند.\cite{Software-development-history}

\noindent \textbf{مزایا:} مدیریت مؤثر ریسک‌ها، انعطاف‌پذیری بالا، مناسب برای پروژه‌های بزرگ و پیچیده.\cite{Software-development-history}

\noindent \textbf{معایب:} نیاز به تخصص بالا در تحلیل ریسک و افزایش هزینه نسبت به مدل‌های ساده‌تر.\cite{Software-development-history}

\subsection{مدل چابک (\lr{Agile}) و ظهور \lr{DevOps}}
در دهه 2000، با انتشار مانیفست چابک (\lr{Agile Manifesto})، پارادایم جدیدی در مهندسی نرم‌افزار شکل گرفت. روش‌های چابک مانند XP، اسکرام (Scrum) و کانبان (Kanban) بر همکاری تیمی، تحویل سریع نسخه‌های قابل اجرا، پاسخ به تغییرات و ارتباط مستمر با مشتری تمرکز دارند.\cite{Software-development-history}

\noindent \textbf{مزایا:} تعامل مستقیم با مشتری، بازخورد سریع، چرخه تحویل کوتاه‌تر، کیفیت بالاتر، افزایش رضایت مشتری، و کاهش خطاهای عملیاتی.\cite{Software-development-history}

\noindent \textbf{معایب:} نیاز به فرهنگ سازمانی جدید، ابزارهای پیشرفته و یادگیری مستمر، دشواری در مستندسازی رسمی.\cite{Software-development-history}

به مرور، DevOps به‌عنوان گامی تکمیلی در این مسیر پدیدار شد. با گسترش DevOps، چرخه‌ی توسعه و عملیات به‌صورت یکپارچه درآمد تا تحویل مداوم (\lr{Continuous Delivery})، استقرار خودکار (\lr{Continuous Deployment}) و نظارت مستمر فراهم شود. DevOps به نوعی ادامه و بلوغ طبیعی Agile به‌شمار می‌رود که فاصله‌ی بین تیم توسعه و تیم زیرساخت را از میان برداشته است. \cite{Software-development-history}